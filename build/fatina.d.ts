// Generated by dts-bundle v0.7.3

export let plugin: any;
export { EasingType as Easing };
export let time: number;
export function Elapsed(): number;
export function MainTicker(): ITicker;
export function AddListenerCreated(cb: (control: IControl) => void): void;
export function RemoveListenerCreated(cb: (control: IControl) => void): void;
export function Init(disableAutoTick?: boolean): boolean;
export function SetTimescale(scale: number): void;
export function Pause(): void;
export function Resume(): void;
export function SetLog(level: Log): void;
export function SetSafe(isSafe: boolean): void;
export function Destroy(): void;
export function Update(timestamp: number): any;
export function Tween(obj: any, properties: string[]): ITween;
export function Sequence(list?: tween[] | sequence[] | IPlayable[]): ISequence;
export function Delay(duration: number): IPlayable;
export function SetTimeout(fn: () => void, duration: number): IPlayable;
export function SetInterval(fn: () => void, duration: number): IPlayable;
export function Ticker(): ITicker;
export function LoadPlugin(newPlugin: IPlugin): void;

export enum Log {
    None = 0,
    Info = 1,
    Debug = 2,
}

export interface IControl {
    elapsed: number;
    duration: number;
    state: State;
    Start(): void;
    Pause(): void;
    Resume(): void;
    Kill(): void;
    Reset(): void;
    Skip(finalValue?: boolean): void;
    IsIdle(): boolean;
    IsRunning(): boolean;
    IsFinished(): boolean;
    IsPaused(): boolean;
}

export interface IPlayable extends IControl {
    state: State;
    SetParent(ticker: ITicker): IPlayable;
    Start(): IPlayable;
    SetLoop(loop: number): IPlayable;
    SetSettings(settings: ISettings): IPlayable;
    OnStart(cb: () => void): IPlayable;
    OnRestart(cb: () => void): IPlayable;
    OnUpdate(cb: (dt: number, progress: number) => void): IPlayable;
    OnKilled(cb: () => void): IPlayable;
    OnComplete(cb: () => void): IPlayable;
}

export interface IPlugin {
    readonly name: string;
    Init(fatina: any): void;
}

export interface ISequence extends IControl {
    Count: number;
    Start(): ISequence;
    SetParent(ticker: ITicker): ISequence;
    SetTimescale(scale: number): ISequence;
    SetLoop(loop: number): ISequence;
    SetSettings(settings: ISettings): ISequence;
    Append(tween: ITween | ISequence): ISequence;
    AppendCallback(cb: () => void): ISequence;
    AppendInterval(duration: number): ISequence;
    Prepend(tween: ITween | ISequence): ISequence;
    PrependCallback(cb: () => void): ISequence;
    PrependInterval(duration: number): ISequence;
    Join(tween: ITween | ISequence): ISequence;
    OnStart(cb: () => void): ISequence;
    OnRestart(cb: () => void): ISequence;
    OnStepStart(cb: (tween: ITween | IPlayable) => void): ISequence;
    OnStepEnd(cb: (index: ITween | IPlayable) => void): ISequence;
    OnUpdate(cb: (dt: number, progress: number) => void): ISequence;
    OnKilled(cb: () => void): ISequence;
    OnComplete(cb: () => void): ISequence;
}

export interface ITicker extends IControl {
    AddTickListener(cb: (dt: number) => void): void;
    RemoveTickListener(cb: (dt: number) => void): void;
    SetTimescale(scale: number): void;
}

export interface ITween extends IControl {
    Init(object: any, properties: string[]): void;
    Start(): ITween;
    From(from: any): ITween;
    To(to: any, duration: number): ITween;
    Modify(diff: any, updateTo: boolean): void;
    Reverse(): void;
    Yoyo(time: number): ITween;
    SetParent(ticker: ITicker): ITween;
    SetLoop(loop: number): ITween;
    SetSteps(steps: number): ITween;
    SetRelative(relative: boolean): ITween;
    SetEasing(type: EasingType | string): ITween;
    SetTimescale(scale: number): ITween;
    ToSequence(): ISequence;
    SetSettings(settings: ISettings): ITween;
    OnStart(cb: () => void): ITween;
    OnUpdate(cb: (dt: number, progress: number) => void): ITween;
    OnRestart(cb: () => void): ITween;
    OnKilled(cb: () => void): ITween;
    OnComplete(cb: () => void): ITween;
}

export enum EasingType {
    Linear = "linear",
    InQuad = "inQuad",
    OutQuad = "outQuad",
    InOutQuad = "inOutQuad",
    InCubic = "inCubic",
    OutCubic = "outCubic",
    InOutCubic = "inOutCubic",
    InQuart = "inQuart",
    OutQuart = "outQuart",
    InOutQuart = "inOutQuart",
    InSine = "inSine",
    OutSine = "outSine",
    InOutSine = "inOutSine",
    InCirc = "inCirc",
    OutCirc = "outCirc",
    InOutCirc = "inOutCirc",
    InQuint = "inQuint",
    OutQuint = "outQuint",
    InOutQuint = "inOutQuint",
    InExponential = "inExponential",
    OutExponential = "outExponential",
    InOutExponential = "inOutExponential",
    InElastic = "inElastic",
    OutElastic = "outElastic",
    InOutElastic = "inOutElastic",
    InBack = "inBack",
    OutBack = "outBack",
    InOutBack = "inOutBack",
    InBounce = "inBounce",
    OutBounce = "outBounce",
    InOutBounce = "inOutBounce",
}

export class Sequence extends BaseTween<Sequence> implements ISequence, ITicker, IPlayable {
    currentTween: (ITween | IPlayable)[] | undefined;
    readonly Count: number;
    constructor(tweens?: ITween[] | ISequence[] | IPlayable[]);
    protected LoopInit(): void;
    AddTickListener(cb: (dt: number) => void): void;
    RemoveTickListener(cb: (dt: number) => void): void;
    Append(tween: ITween | ISequence): ISequence;
    AppendCallback(cb: () => void): ISequence;
    AppendInterval(duration: number): ISequence;
    Prepend(tween: ITween | ISequence): ISequence;
    PrependCallback(cb: () => void): ISequence;
    PrependInterval(duration: number): ISequence;
    Skip(finalValue?: boolean): void;
    Kill(): void;
    Join(tween: ITween | ISequence): ISequence;
    OnStepStart(cb: (index: ITween | IPlayable) => void): ISequence;
    OnStepEnd(cb: (index: ITween | IPlayable) => void): ISequence;
}

export class Tween extends BaseTween<Tween> implements ITween {
    constructor(object: any, properties: string[]);
    Init(object: any, properties: string[]): void;
    protected Validate(): void;
    protected CheckPosition(): void;
    From(from: any): ITween;
    To(to: any, duration: number): ITween;
    SetRelative(relative: boolean): ITween;
    Modify(diff: any, updateTo: boolean): void;
    Reset(skipParent?: boolean): void;
    Reverse(): void;
    Yoyo(time: number): ITween;
    SetSteps(steps: number): ITween;
    ToSequence(): ISequence;
    SetEasing(type: EasingType | string): ITween;
    protected LoopInit(): void;
}

export enum State {
    Idle = 0,
    Run = 1,
    Pause = 2,
    Finished = 3,
    Killed = 4,
}

export interface ISettings {
    logLevel: Log;
    safe: boolean;
}

export abstract class BaseTween<T extends BaseTween<any>> {
    protected eventStart: {
        (): void;
    }[] | undefined;
    protected eventRestart: {
        (): void;
    }[] | undefined;
    protected eventUpdate: {
        (dt: number, progress: number): void;
    }[] | undefined;
    protected eventKill: {
        (): void;
    }[] | undefined;
    protected eventComplete: {
        (): void;
    }[] | undefined;
    elapsed: number;
    duration: number;
    timescale: number;
    state: State;
    protected loop: ITweenProperty | undefined;
    protected yoyo: ITweenProperty | undefined;
    protected parent: ITicker;
    protected tickCb: (dt: number) => void;
    Start(): T;
    Reset(skipParent?: boolean): void;
    ResetAndStart(dtRemains: number): void;
    SetParent(ticker: ITicker): T;
    SetTimescale(scale: number): T;
    Pause(): void;
    Resume(): void;
    Skip(finalValue?: boolean): void;
    Kill(): void;
    SetLoop(loop: number): T;
    SetSettings(settings: ISettings): T;
    IsIdle(): boolean;
    IsRunning(): boolean;
    IsFinished(): boolean;
    IsPaused(): boolean;
    protected Complete(): void;
    protected RemoveParentListener(): void;
    protected CheckPosition(): void;
    protected Validate(): void;
    protected LoopInit(): void;
    protected Info(level: Log, message: string, data?: any): void;
    protected EmitEvent(listeners: any, args?: any): void;
    OnStart(cb: () => void): T;
    OnRestart(cb: () => void): T;
    OnUpdate(cb: (dt: number, progress: number) => void): T;
    OnKilled(cb: () => void): T;
    OnComplete(cb: () => void): T;
}

export interface ITweenProperty {
    original: number;
    value: number;
}

